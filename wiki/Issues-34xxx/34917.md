# Issue 34917: Objects that are equal should have the same hash.

archive/issues_034680.json:
```json
{
    "assignees": [],
    "body": "<div id=\"comment:0\"></div>\n\nFrom the python doc (https://docs.python.org/3/reference/datamodel.html?#object.__hash__)\n\n```\nThe only required property is that objects which compare equal have the same hash value\n```\n\nThis is not the case for lots of Sage objects.\n\nA quick search shows that this problem was already noticed before in specific cases: #26944, #19304.\n\nBut it is widespread throughout Sage, due, I think, to the coercion system that make it easy to compare object of different classes.\n\nSome examples below:\n\n```python\nimport fractions\nZZx.<x> = ZZ[]\n\ndef test_eq_hash (a, b):\n  eq = a == b\n  same_hash = hash(a) == hash(b)\n  implication = not eq or same_hash\n  print (f'{eq=!s:7} {same_hash=!s:7} => {\"OK\" if implication else \"Error\"}')\n\n```\n\n```sage\nsage: test_eq_hash (1, 1.0)\neq=True    same_hash=True    => OK\nsage: test_eq_hash (1, float(1.0))\neq=True    same_hash=True    => OK\nsage: test_eq_hash (float(0.1), 0.1)\neq=True    same_hash=True    => OK\n\nsage: test_eq_hash (fractions.Fraction (int(1), int(2)), 0.5)\neq=False   same_hash=True    => OK\nsage: test_eq_hash (fractions.Fraction (int(1), int(2)), float(0.5))\neq=True    same_hash=True    => OK\nsage: test_eq_hash (1/2, 0.5)\neq=True    same_hash=False   => Error\nsage: test_eq_hash (fractions.Fraction (int(1), int(2)), 1/2)\neq=False   same_hash=False   => OK\n\nsage: test_eq_hash (fractions.Fraction (int(1), int(10)), 0.1)\neq=False   same_hash=False   => OK\nsage: test_eq_hash (fractions.Fraction (int(1), int(10)), float(0.1))\neq=False   same_hash=False   => OK\nsage: test_eq_hash (1/10, 0.1)\neq=True    same_hash=False   => Error\nsage: test_eq_hash (ZZx(1), 1)\neq=True    same_hash=True    => OK\nsage: test_eq_hash (ZZx(1), 1.0)\neq=True    same_hash=True    => OK\n\nsage: test_eq_hash (ZZx(1)/ZZx(2), 1/2)\neq=True    same_hash=False   => Error\nsage: test_eq_hash (ZZx(1)/ZZx(2), 0.5)\neq=True    same_hash=False   => Error\nsage: test_eq_hash (ZZx(1)/ZZx(2), float(0.5))\neq=True    same_hash=False   => Error\n\nsage: test_eq_hash (1, QQbar(1))\neq=True    same_hash=False   => Error\nsage: test_eq_hash (1/2, QQbar(1/2))\neq=True    same_hash=False   => Error\nsage: test_eq_hash (1, CC(1))\neq=True    same_hash=True    => OK\nsage: test_eq_hash (1/2, CC(1/2))\neq=True    same_hash=False   => Error\n\n\n\n```\n\n(Note: the test with the Fraction class need the int conversion to prevent bug #34916)\n\nComponent: **misc**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/34917_\n\n",
    "created_at": "2023-01-17T14:35:34Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
        "https://github.com/sagemath/sage/labels/bug",
        "https://github.com/sagemath/sage/labels/needs%20review"
    ],
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "Objects that are equal should have the same hash.",
    "type": "issue",
    "updated_at": "2023-01-19T17:31:43Z",
    "url": "https://github.com/sagemath/sage/issues/34917",
    "user": "https://github.com/sagetrac-bouvier"
}
```
<div id="comment:0"></div>

From the python doc (https://docs.python.org/3/reference/datamodel.html?#object.__hash__)

```
The only required property is that objects which compare equal have the same hash value
```

This is not the case for lots of Sage objects.

A quick search shows that this problem was already noticed before in specific cases: #26944, #19304.

But it is widespread throughout Sage, due, I think, to the coercion system that make it easy to compare object of different classes.

Some examples below:

```python
import fractions
ZZx.<x> = ZZ[]

def test_eq_hash (a, b):
  eq = a == b
  same_hash = hash(a) == hash(b)
  implication = not eq or same_hash
  print (f'{eq=!s:7} {same_hash=!s:7} => {"OK" if implication else "Error"}')

```

```sage
sage: test_eq_hash (1, 1.0)
eq=True    same_hash=True    => OK
sage: test_eq_hash (1, float(1.0))
eq=True    same_hash=True    => OK
sage: test_eq_hash (float(0.1), 0.1)
eq=True    same_hash=True    => OK

sage: test_eq_hash (fractions.Fraction (int(1), int(2)), 0.5)
eq=False   same_hash=True    => OK
sage: test_eq_hash (fractions.Fraction (int(1), int(2)), float(0.5))
eq=True    same_hash=True    => OK
sage: test_eq_hash (1/2, 0.5)
eq=True    same_hash=False   => Error
sage: test_eq_hash (fractions.Fraction (int(1), int(2)), 1/2)
eq=False   same_hash=False   => OK

sage: test_eq_hash (fractions.Fraction (int(1), int(10)), 0.1)
eq=False   same_hash=False   => OK
sage: test_eq_hash (fractions.Fraction (int(1), int(10)), float(0.1))
eq=False   same_hash=False   => OK
sage: test_eq_hash (1/10, 0.1)
eq=True    same_hash=False   => Error
sage: test_eq_hash (ZZx(1), 1)
eq=True    same_hash=True    => OK
sage: test_eq_hash (ZZx(1), 1.0)
eq=True    same_hash=True    => OK

sage: test_eq_hash (ZZx(1)/ZZx(2), 1/2)
eq=True    same_hash=False   => Error
sage: test_eq_hash (ZZx(1)/ZZx(2), 0.5)
eq=True    same_hash=False   => Error
sage: test_eq_hash (ZZx(1)/ZZx(2), float(0.5))
eq=True    same_hash=False   => Error

sage: test_eq_hash (1, QQbar(1))
eq=True    same_hash=False   => Error
sage: test_eq_hash (1/2, QQbar(1/2))
eq=True    same_hash=False   => Error
sage: test_eq_hash (1, CC(1))
eq=True    same_hash=True    => OK
sage: test_eq_hash (1/2, CC(1/2))
eq=True    same_hash=False   => Error



```

(Note: the test with the Fraction class need the int conversion to prevent bug #34916)

Component: **misc**

_Issue created by migration from https://trac.sagemath.org/ticket/34917_





---

archive/issue_events_472890.json:
```json
{
    "actor": "https://github.com/sagetrac-bouvier",
    "created_at": "2023-01-17T14:35:34Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/34917",
    "milestone_number": null,
    "milestone_title": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/34917#event-472890"
}
```



---

archive/issue_events_472891.json:
```json
{
    "actor": "https://github.com/sagetrac-bouvier",
    "created_at": "2023-01-17T14:35:34Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/34917",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
    "label_color": "ffbb00",
    "label_name": "p: major / 3",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/34917#event-472891"
}
```



---

archive/issue_events_472892.json:
```json
{
    "actor": "https://github.com/sagetrac-bouvier",
    "created_at": "2023-01-17T14:35:34Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/34917",
    "label": "https://github.com/sagemath/sage/labels/bug",
    "label_color": "d73a4a",
    "label_name": "bug",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/34917#event-472892"
}
```



---

archive/issue_comments_562624.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nHow do you propose to solve this? One of the issues is that in Sage, equality is not transitive:\n\n```\nsage: a = Integers(1)(1) # a=1 in the \"integers mod 1\"\nsage: b = 1\nsage: c = 8\nsage: a == b\nTrue\nsage: a == c\nTrue\nsage: b == c\nFalse\n```\nIndeed, this `a` will compare as equal to any integer. Do you want all integers to have the same hash? The other alternative is to change the meaning of equality in Sage. That would be a very big job and would be very backwards-incompatible.",
    "created_at": "2023-01-17T20:46:36Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34917",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34917#issuecomment-562624",
    "user": "https://github.com/jhpalmieri"
}
```

<div id="comment:1" align="right">comment:1</div>

How do you propose to solve this? One of the issues is that in Sage, equality is not transitive:

```
sage: a = Integers(1)(1) # a=1 in the "integers mod 1"
sage: b = 1
sage: c = 8
sage: a == b
True
sage: a == c
True
sage: b == c
False
```
Indeed, this `a` will compare as equal to any integer. Do you want all integers to have the same hash? The other alternative is to change the meaning of equality in Sage. That would be a very big job and would be very backwards-incompatible.



---

archive/issue_comments_562625.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nThe reality is that with many sage objects, the best you can hope for is \"objects with the same parent that compare equal, have the same hash\" -- and I think that counts as a rule we should strive to uphold. It means that dictionaries act properly when the keys are taken from a common parent.\n\nIt's an unfortunate compromise and definitely one that bites us in many implementation details (for instance, in caches, construction parameters are often used to build up keys, and they by no means can be guaranteed to lie in the same parent).\n\nBut there are definite benefits from this compromise: for instance that `[a for a in GF(17) if a**4 == 1]` actually works. This ship has sailed: sagemath does not strictly conform to python's rules and changing that would be too painful for existing sagemath software. Sagemath will never be a fully compatible python library, just for that reason already.",
    "created_at": "2023-01-18T05:56:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34917",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34917#issuecomment-562625",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:2" align="right">comment:2</div>

The reality is that with many sage objects, the best you can hope for is "objects with the same parent that compare equal, have the same hash" -- and I think that counts as a rule we should strive to uphold. It means that dictionaries act properly when the keys are taken from a common parent.

It's an unfortunate compromise and definitely one that bites us in many implementation details (for instance, in caches, construction parameters are often used to build up keys, and they by no means can be guaranteed to lie in the same parent).

But there are definite benefits from this compromise: for instance that `[a for a in GF(17) if a**4 == 1]` actually works. This ship has sailed: sagemath does not strictly conform to python's rules and changing that would be too painful for existing sagemath software. Sagemath will never be a fully compatible python library, just for that reason already.



---

archive/issue_comments_562626.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nReplying to [John Palmieri](#comment%3A1):\n> How do you propose to solve this? One of the issues is that in Sage, equality is not transitive:\n> \n> ```\n> sage: a = Integers(1)(1) # a=1 in the \"integers mod 1\"\n> sage: b = 1\n> sage: c = 8\n> sage: a == b\n> True\n> sage: a == c\n> True\n> sage: b == c\n> False\n> ```\n> Indeed, this `a` will compare as equal to any integer. Do you want all integers to have the same hash? The other alternative is to change the meaning of equality in Sage. That would be a very big job and would be very backwards-incompatible.\n\nThe fact that the equality is not transitive is not a problem per se, it appears in the python standard library https://github.com/python/cpython/issues/93069 (for non hashable object). The problem is that in this case the objet should **not** be hashable (or all have the same hash which would be unusable)\n\nOtherwise, it can lead to very weird behavior, for example, update on dict becomes order-dependent:\n\n```python\nsage: import fractions\nsage: a = 0.5\nsage: b = float(0.5)\nsage: c = fractions.Fraction (int(1), int(2))\nsage: a == b\nTrue\nsage: a == c\nFalse\nsage: b == c\nTrue\nsage: D = {a: 1}\nsage: D.update ({ b: 2, c: 3})\nsage: D\n{0.500000000000000: 3}\nsage: \nsage: D2 = {a: 1}\nsage: D2.update ({ c:3, b: 2})\nsage: D2\n{0.500000000000000: 1, Fraction(1, 2): 2}\n```",
    "created_at": "2023-01-18T13:46:30Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34917",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34917#issuecomment-562626",
    "user": "https://github.com/sagetrac-bouvier"
}
```

<div id="comment:3" align="right">comment:3</div>

Replying to [John Palmieri](#comment%3A1):
> How do you propose to solve this? One of the issues is that in Sage, equality is not transitive:
> 
> ```
> sage: a = Integers(1)(1) # a=1 in the "integers mod 1"
> sage: b = 1
> sage: c = 8
> sage: a == b
> True
> sage: a == c
> True
> sage: b == c
> False
> ```
> Indeed, this `a` will compare as equal to any integer. Do you want all integers to have the same hash? The other alternative is to change the meaning of equality in Sage. That would be a very big job and would be very backwards-incompatible.

The fact that the equality is not transitive is not a problem per se, it appears in the python standard library https://github.com/python/cpython/issues/93069 (for non hashable object). The problem is that in this case the objet should **not** be hashable (or all have the same hash which would be unusable)

Otherwise, it can lead to very weird behavior, for example, update on dict becomes order-dependent:

```python
sage: import fractions
sage: a = 0.5
sage: b = float(0.5)
sage: c = fractions.Fraction (int(1), int(2))
sage: a == b
True
sage: a == c
False
sage: b == c
True
sage: D = {a: 1}
sage: D.update ({ b: 2, c: 3})
sage: D
{0.500000000000000: 3}
sage: 
sage: D2 = {a: 1}
sage: D2.update ({ c:3, b: 2})
sage: D2
{0.500000000000000: 1, Fraction(1, 2): 2}
```



---

archive/issue_comments_562627.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nSo Sage Integers should not be hashable?",
    "created_at": "2023-01-18T16:15:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34917",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34917#issuecomment-562627",
    "user": "https://github.com/jhpalmieri"
}
```

<div id="comment:4" align="right">comment:4</div>

So Sage Integers should not be hashable?



---

archive/issue_comments_562628.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nReplying to [John Palmieri](#comment%3A4):\n> So Sage Integers should not be hashable?\n\nI agree that it is not a desirable solution.\nThe alternative is to restrict more carefully the coercion system, which seems impossible for backward-compatibility reasons.\nSo maybe this ticket can be closed as a wont-fix.\n\nNote that the wierd behavior from my previous post can also be trigger with more realistic values:\n\n```python\nsage: a = Integers(2)(1)\nsage: b = 1\nsage: c = Integers(3)(1)\n```",
    "created_at": "2023-01-18T16:30:07Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34917",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34917#issuecomment-562628",
    "user": "https://github.com/sagetrac-bouvier"
}
```

<div id="comment:5" align="right">comment:5</div>

Replying to [John Palmieri](#comment%3A4):
> So Sage Integers should not be hashable?

I agree that it is not a desirable solution.
The alternative is to restrict more carefully the coercion system, which seems impossible for backward-compatibility reasons.
So maybe this ticket can be closed as a wont-fix.

Note that the wierd behavior from my previous post can also be trigger with more realistic values:

```python
sage: a = Integers(2)(1)
sage: b = 1
sage: c = Integers(3)(1)
```



---

archive/issue_comments_562629.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nReplying to [Cyril Bouvier](#comment%3A5):\n> Note that the wierd behavior from my previous post can also be trigger with more realistic values:\n> \n> ```python\n> sage: a = Integers(2)(1)\n> sage: b = 1\n> sage: c = Integers(3)(1)\n> ```\n\nThe problem in that example is not due to hash inequalities, since these elements all hash to 1. Weirdness in this example just comes from `a==b and b==c` but `a!=c`. In fact, in the original example, inequality of hash values of equal objects did not come into play either, so in that sense the two examples indeed illustrate the same issue, but it's not due to hash values:\n\n```\nsage: import fractions\nsage: hash(0.5)\n1152921504606846976\nsage: hash(float(0.5))\n1152921504606846976\nsage: hash(fractions.Fraction(1r,2r))\n1152921504606846976\n```",
    "created_at": "2023-01-19T17:27:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34917",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34917#issuecomment-562629",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:6" align="right">comment:6</div>

Replying to [Cyril Bouvier](#comment%3A5):
> Note that the wierd behavior from my previous post can also be trigger with more realistic values:
> 
> ```python
> sage: a = Integers(2)(1)
> sage: b = 1
> sage: c = Integers(3)(1)
> ```

The problem in that example is not due to hash inequalities, since these elements all hash to 1. Weirdness in this example just comes from `a==b and b==c` but `a!=c`. In fact, in the original example, inequality of hash values of equal objects did not come into play either, so in that sense the two examples indeed illustrate the same issue, but it's not due to hash values:

```
sage: import fractions
sage: hash(0.5)
1152921504606846976
sage: hash(float(0.5))
1152921504606846976
sage: hash(fractions.Fraction(1r,2r))
1152921504606846976
```



---

archive/issue_comments_562630.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nIn the face of non-transitivity of equality in sage, the nominal requirement on hashes becomes untenable: it would force us to use a constant hash function, which would give atrocious performance and still inconsistent results, because python itself uses non-constant hash functions in its numerical stack (and we do need to interact with that). Close as \"won'tfix\"?",
    "created_at": "2023-01-19T17:31:43Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/34917",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/34917#issuecomment-562630",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:7" align="right">comment:7</div>

In the face of non-transitivity of equality in sage, the nominal requirement on hashes becomes untenable: it would force us to use a constant hash function, which would give atrocious performance and still inconsistent results, because python itself uses non-constant hash functions in its numerical stack (and we do need to interact with that). Close as "won'tfix"?



---

archive/issue_events_472893.json:
```json
{
    "actor": "https://github.com/nbruin",
    "created_at": "2023-01-19T17:31:43Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/34917",
    "milestone_number": null,
    "milestone_title": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/34917#event-472893"
}
```



---

archive/issue_events_472894.json:
```json
{
    "actor": "https://github.com/nbruin",
    "created_at": "2023-01-19T17:31:43Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/34917",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/34917#event-472894"
}
```
